# diffadd
After comparing through diff, use patch to append the new configuration to the old configuration.

## 工程说明
- busybox 目录下为 x86_64/aarch64 架构下源码静态编译后的二进制可执行文件
    - 可在国产化系统下运行，银河麒麟，中标麒麟，阿里龙溪，华为欧拉，统信os 等国产化系统中使用
    - 如不可信来源，可从 busybox 源码进行自行编译，替换进去即可。

- 全程使用 `busybox` 中命令的集合，排除系统中的强依赖。
    - 主要使用 `diff` 和 `patch` 命令组合来解决对旧配置文件进行新增加配置行。

## 使用说明

```shell
Usage: ./diffadd.sh <old_config_file> <new_config_file>

<old_config_file> 要比较旧配置文件，建议填写文件的绝对路径。

<new_config_file> 要比较新的配置文件，建议填写文件的绝对路径。

```

## 脚本描述：
1. 对比旧的与新的文件配置，只将新的文件配置写入旧文件中

2. 针对 yaml/yml 文件的格式，会采取激进的配置追加方式
    - 对 : 表示的键值对 可完好的适配新配置追加
   - 对 - 表示的列表项格式数据做覆盖
   - 对 # 表示的注释说明，不跟踪不追加到配置中

 3. 其它通用类型的文件格式，使用温和地追加配置，会存在部分配置追加不上问题。
   - .xml 受制于 元素和属性 的不确定性，以及命名的多样性，无法做匹配处理
   - .json 的数据类型构成的复杂多样性，无法做匹配处理


## 脚本过程：
1. 将脚本中使用到的命令绑定来自 busybox 中的命令集合
2. 通过入参获取待对比的旧文件和新文件
3. 通过 diff -u 比较差异之处，两个处理
   - 当只有新增加的差异，直接通过 patch 打补丁完成新配置追加

   - 当存在不同差异时，判断是否为 yaml/yml 格式文件
       - 不是 yaml/yml 文件，则从里面找到只有新增的内容，追加到旧配置文件中，会存在漏追加配置。

       - 是 yaml/yml 文件，则在中间的临时文件中，将新旧不同处配置做替换后（将旧配置覆盖新配置，将差异外变成相同）
           最终，通过 diff -u 得到全部只有新增加的内容，再追加到旧配置文件中。
           - 第一次处理后，还是存在旧配置文件比新配置文件多出差异处，则再进行第二次处理：
               - 将旧配置不同之处，在再新生成中间临时文件，反向对原临时中间文件打补丁，做同化处理。
                   - 再次检查做 diff -u 检查，如不存在差异正常退出，存在差异：
                       - 只有新增加的，正常追加配置
                       - 还是存在不同的差异，则不再进行追加配置，差异之处，属于旧配置文件独有选项。





